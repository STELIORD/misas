# AUTOGENERATED! DO NOT EDIT! File to edit: 01_local_interpret.ipynb (unless otherwise specified).

__all__ = ['plot_generic_series', 'eval_generic_series', 'rotationTransform', 'plot_rotation_series',
           'eval_rotation_series', 'plot_rotation', 'cropTransform', 'plot_crop_series', 'eval_crop_series',
           'plot_crop', 'brightnessTransform', 'plot_brightness_series', 'eval_bright_series', 'plot_brightness',
           'plot_contrast_series', 'contrast_series', 'plot_contrast', 'plot_zoom_series', 'zoom_series', 'plot_zoom',
           'plot_dihedral_series']

# Internal Cell
from fastai.vision import *
import pandas as pd
from tqdm.notebook import tqdm
import matplotlib.pyplot as plt
import gif
import numpy as np

# Internal Cell
def dice_by_component(predictedMask, trueMask, component = 1):
    dice = Tensor([1])
    pred = predictedMask.data == component
    msk = trueMask.data == component
    intersect = pred&msk
    total = pred.sum() + msk.sum()
    if total > 0:
        dice = 2 * intersect.sum().float() / total
    return dice.item()

# Cell
def plot_generic_series(
        image,
        model,
        transform_function,
        start=0,
        end=180,
        num=5,
        param_name='param',
        log_steps=False,
        prep_function=None
    ):
    fig, axs = plt.subplots(1,num,figsize=(16,6))
    steps = np.linspace(start,end,num)
    if log_steps:
        steps = np.exp(np.linspace(log(start),log(end),num))
    for param, ax in zip(steps, axs.flatten()):
        img = image.clone()
        img = transform_function(img, param)
        if prep_function:
            img = prep_function(img)
        pred = model.predict(img)[0]
        img.show(ax=ax, title=f'{param_name}={param:.2f}', y = pred)

# Cell
def eval_generic_series(
        image,
        mask,
        model,
        transform_function,
        start=0,
        end=360,
        step_size=5,
        param_name="param",
        mask_transform_function=None,
        prep_function=None,
        components=['bg', 'c1','c2']
    ):
    results = list()
    for param in tqdm(np.arange(start, end, step_size)):
        img = image.clone()
        trueMask = mask.clone()
        img = transform_function(img, param)
        if mask_transform_function:
            trueMask = mask_transform_function(trueMask, param)
        if prep_function:
            img = prep_function(img)
            trueMask = prep_function(trueMask)
        prediction = model.predict(img)[0]
        # prediction._px = prediction._px.float()
        result = [param]
        for i in range(len(components)):
            result.append(dice_by_component(prediction, trueMask, component = i))
        results.append(result)

    results = pd.DataFrame(results,columns = [param_name, *components])
    return results

# Cell
def rotationTransform(image, deg):
    return image.rotate(degrees=int(deg))

def plot_rotation_series(image, model, start=0, end=180, num=6, **kwargs):
    plot_generic_series(image,model,rotationTransform, start=start, end=end, num=num, param_name="degrees", **kwargs)

# Cell
def eval_rotation_series(image, mask, model, step_size=5, start=0, end=360, **kwargs):
    return eval_generic_series(
        image,
        mask,
        model,
        rotationTransform,
        start=start,
        end=end,
        step_size=step_size,
        mask_transform_function=rotationTransform,
        param_name="deg",
        **kwargs
    )

# Cell
@gif.frame
def plot_rotation(image_function, model, deg=90):
    img = image_function().resize(256).rotate(degrees=int(deg))
    return img.show(title=f'degrees={deg}', y =  model.predict(img)[0])

# Cell
def cropTransform(image, pxls):
    image.resize(256)
    image.crop(int(pxls))
    image.rotate(180)
    image.crop_pad(256,padding_mode='zeros')
    image.rotate(180)
    return image

def plot_crop_series(image, model, start=256, end=56, num=5, **kwargs):
    plot_generic_series(image,model,cropTransform, start=start, end=end, num=num, param_name="pixels", **kwargs)

# Cell
def eval_crop_series(image, mask, model, start=56, end=256,step_size=5,crop_mask=False,**kwargs):
    mask_transform_function = None
    if crop_mask:
        mask_transform_function = cropTransform
    return eval_generic_series(
        image,
        mask,
        model,
        cropTransform,
        start=start,
        end=end,
        step_size=step_size,
        param_name='pixels',
        mask_transform_function=mask_transform_function,
        **kwargs
    )

# Cell
@gif.frame
def plot_crop(image_function, model, pxls, **kwargs):
    img = image_function().resize(256).crop(pxls).rotate(180).crop_pad(256, padding_mode = 'zeros').rotate(180)
    return img.show(title=f'cropping={pxls}', y =  model.predict(img)[0], **kwargs)

# Cell
def brightnessTransform(image, light):
    return image.brightness(light)

def plot_brightness_series(image, model, start=0.05, end=0.95, num=5, **kwargs):
    plot_generic_series(image,model,brightnessTransform, start=start, end=end, num=num, param_name="brightness", **kwargs)

# Cell
def eval_bright_series(image, mask, model, start=0.05, end=0.95, step_size=0.05, param_name="brightness", **kwargs):
    return eval_generic_series(
        image,
        mask,
        model,
        brightnessTransform,
        start=start,
        end=end,
        step_size=step_size,
        param_name=param_name,
        **kwargs
    )

# Cell
@gif.frame
def plot_brightness(image_function, model, light):
    img = image_function().resize(256).brightness(light)
    return img.show(title=f'brightness={light:.2f}', y =  model.predict(img)[0])

# Cell
def plot_contrast_series(image, model, start=0.1, end=7, num=5, **kwargs):
    contrastTransform = lambda image, scale: image.resize(256).contrast(scale)
    plot_generic_series(image,model,contrastTransform, start=start, end=end, num=num, param_name="scale", log_steps=True, **kwargs)

# Cell
def contrast_series(image_function, mask_function, model, step_size=0.5):
    trueMask = mask_function().resize(256)
    results1 = list()
    for scale in tqdm(np.arange(0, 7, step_size)):
        image = image_function()
        image.resize(256)
        ContrastImage = contrast(image, scale)
        prediction = model.predict(ContrastImage)[0]
        prediction._px = prediction._px.float()

        diceLV1 = dice_by_component(prediction, trueMask, component = 1)
        diceMY1 = dice_by_component(prediction, trueMask, component = 2)
        results1.append([scale, diceLV1, diceMY1])

    results1 = pd.DataFrame(results1,columns = ['scale', 'diceLV1', 'diceMY1'])
    return results1

# Cell
@gif.frame
def plot_contrast(image_function, model, scale):
    img = image_function().resize(256).contrast(scale=scale)
    return img.show(title=f'contrast={scale}', y =  model.predict(img)[0])

# Cell
def plot_zoom_series(image, model, start=1.00, end=2.75, num=5, **kwargs):
    zoomTransform = lambda image, scale1: image.resize(256).zoom(scale1)
    plot_generic_series(image,model,zoomTransform, start=start, end=end, num=num, param_name="scale", **kwargs)

# Cell
def zoom_series(image_function, mask_function, model, step_size=0.75):
    results = list()
    for scale1 in tqdm(np.arange(1., 3.0, step_size)):
        trueMask = mask_function().resize(256)
        trueMask.zoom(scale = scale1)
        image = image_function()
        image.resize(256)
        zoomImage = image.zoom(scale = scale1)
        prediction = model.predict(zoomImage)[0]
        prediction._px = prediction._px.float()

        diceLV = dice_by_component(prediction, trueMask, component = 1)
        diceMY = dice_by_component(prediction, trueMask, component = 2)
        results.append([scale1, diceLV, diceMY])

    results = pd.DataFrame(results,columns = ['scale1', 'diceLV', 'diceMY'])
    return results


# Cell
@gif.frame
def plot_zoom(image_function, model, scale, **kwargs):
    img = image_function().resize(256).zoom(scale = scale)
    return img.show(title=f'zoom={scale}', y =  model.predict(img)[0], **kwargs)

# Cell
def plot_dihedral_series(image, model, start=0, end=7, num=8):
    dihedralTransform = lambda image, sym_im: image.resize(256).dihedral(k=int(sym_im))
    plot_generic_series(image,model,dihedralTransform, start=start, end=end, num=num, param_name="dihedral")